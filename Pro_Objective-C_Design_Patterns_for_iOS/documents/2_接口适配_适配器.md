## 适配器模式的定义

> 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
>
> ——《设计模式》（Addison-Wesley，1994）

适配器模式验证了以下的至理名言：

> **计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。**

适配器模式，用于连接两种不同类型的对象，使其毫无问题地协同工作。有时它也称为“包装器”（ wrapper）。其思想很简单。适配器实现客户端所需要的某种接口的行为。同时，它又连接到另一个具有（完全）不同接口与行为的对象。一边是客户端懂得如何使用的目标接口；另一边是客户端一无所知的被适配者，适配器站在两者之间。适配器的主要作用是把被适配者的行为传递给管道另一端的客户端。

### 类适配器

基本上有两种实现适配器的方式。第一种是**通过继承来适配两个接口**，这称为**类适配器**。最早在《设计模式》一书中，类适配器是通过多重继承实现的。书中主要使用的语言是 C++，它并没有 Java 的接口或 Objective-C 的协议这样的语言功能，一切都是类。没有实际实现的类，叫做抽象类。它是一种被用作“抽象”类型的东西，与 Objective-C 不同。 Objective-C 有协议，作为纯粹抽象的一种形式。**在 Objective-C 中，类可以遵守并实现协议，同时又继承超类，达到 C++ 的多重继承的效果**。要在 Objective-C 中实现类适配器，首先需要有定义了客户端要使用的一套行为的协议，然后要用具体的适配器类亲实现这个协议。适配器类同时也要继承被适配者。

![类适配器](https://blog-andy0570-1256077835.cos.ap-shanghai.myqcloud.com/site_Images/070354.png)

在类适配器模式中：

Adapter（适配器）与 Target（目标接口）之间是**接口继承**关系，Adapter 会遵守并实现 Target 声明的协议方法，即 `request` 方法。

Adapter（适配器）与 Adaptee（被适配者）之间是**类继承**关系，Adapter 是 Adaptee 的子类对象，当 Adapter 实现 `request` 方法时，会调用 Adaptee 的 `sepecficRequest` 方法。

Adapter 重载了 Target 的  `request` 方法，但是 Adapter 并没有重载 Adaptee 的 `sepecficRequest` 方法，而是在 Adapter 的 `request` 方法的实现中，调用了超类的 `sepecficRequest` 方法。`request` 方法在运行时向超类发送 `[super sepecficRequest]` 消息。`super` 就是 Adaptee，它在 Adapter 的 `request` 方法的作用域内，按自己的方式执行 `sepecficRequest` 方法。

注：**只有当 Target 是协议而不是类时，类适配器才能够用 Objective-C 来实现**。

### 对象适配器

实现适配器模式的第二种方式称为**对象适配器**。与类适配器不同，对象适配器不继承被适配者，而是组合了一个对它的引用。实现为对象适配器时，它们之间的关系如图所示：

![对象适配器](https://blog-andy0570-1256077835.cos.ap-shanghai.myqcloud.com/site_Images/073256.png)

在对象适配器模式中：

Adapter（适配器）与 Target（目标接口）之间的关系仍然是**接口继承**关系。

而 Adapter（适配器）与 Adaptee（被适配者）之间是**包含**关系，在这种关系下，Adapter 需要保持对 Adaptee 的一个引用。在 `request` 方法中，Adapter 发送 `[adaptee sepecficRequest]` 消息给 adaptee 实例，以间接访问它的行为，然后实现客户端请求的其余部分。由于 Adapter 与 Adaptee 之间是一种**包含**关系，用 Adapter 去适配 Adaptee 的子类也没有什么问题。



### 类适配器与对象适配器的特征对比

类适配器与对象适配器是实现适配器模式的不同方式，但是达成的目的相同。

| 类适配器                                                  | 对象适配器                                                   |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| 只针对单一的具体 Adaptee 类，把 Adaptee 适配到 Target     | 可以适配多个 Adaptee 及其子类                                |
| 易于重载 Adaptee 的行为，因为是通过直接的子类化进行的适配 | 难于重载 Adaptee 的行为，需要借助于子类的对象而不是 Adaptee 本身 |
| 只有一个 Adapter 对象，无需额外的指针间接访问 Adaptee     | 需要额外的指针以间接访问 Adaptee 并适配其行为                |

显然，委托（Delegate）模式属于**对象适配器**。



## 何时使用适配器模式

在以下情形中，可以考虑采用适配器模式：

* 已有类的接口与需求不匹配；
* 想要一个可复用的类，该类能够同可能带有不兼容接口的其他类协作。
* 需要适配一个类的几个不同子类，可是让每一个子类去子类化一个类适配器又不现实。那么可以使用对象适配器（也叫委托）来适配其父类的接口。





























