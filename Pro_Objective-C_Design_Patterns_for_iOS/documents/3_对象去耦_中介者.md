## 中介者模式的定义

> 用一个对象来封装一系列对象的交互方式。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
> ——《设计模式》（Addison-Wesley，1994）

中介者模式是指**用一个对象来封装一组对象之间的交互逻辑**。

中介者模式用于定义一个集中的场所，对象间的交互可以在一个中介者对象中处理。其他对象不必彼此交互，因而减少了它们之间的相互依赖关系。

![中介者模式](https://blog-andy0570-1256077835.cos.ap-shanghai.myqcloud.com/site_Images/034448.png)

抽象的 `Mediator` 定义了用于同 `Colleague` 交互的一般行为。典型的同事（Colleague）是以明确定义的方式进行相互通信的对象，并且彼此紧密依存。`ConcreteMediator` 为 `ConcreteColleague` 定义了更加具体的行为，因此可以子类化 `Mediator`，把各种 `Colleagure` 交互算法应用到相同或不同的 `Colleagure` 类型。如果应用程序只需要一个中介者，有时抽象的 `Mediator` 可以省略。

`Colleague` 的实例有一个 `Mediator` 实例的引用，同时 `Mediator` 的实例知道参与这个组织的每个对象。运行时中介者模式的一种可能的对象结构如图所示：

![中介者模式](https://blog-andy0570-1256077835.cos.ap-shanghai.myqcloud.com/site_Images/035837.png)

中介者模式以中介者内部的复杂性代替交互的复杂性。因为中介者封装与合并了 Colleague 的各种协作逻辑，自身可能变得比它们任何一个都复杂。这会让中介者本身成为无所不知的庞然大物，并且难以维护。

虽然对于处理应用程序的行为分散于不同对象并且对象互相依存的情况，中介者模式非常有用，但是应当注意避免让中介者类过于庞大而难以维护。如果已经这样了，可以考虑使用另一种设计模式把它分解。要创造性地混用和组合各种设计模式解决同一个问题。每个设计模式就像一个乐高积木块。整个应用程序可能要使用彼此配合的种“积木块”来建造。


## 何时使用中介者模式

在以下情形，自然会考虑使用这一模式：

* 对象间的交互虽定义明确然而非常复杂，导致一组对象彼此相互依赖而且难以理解因为对象引用了许多其他对象并与其通讯，导致对象难以复用。
* 想要定制一个分布在多个类中的逻辑或行为，又不想生成太多子类。





























